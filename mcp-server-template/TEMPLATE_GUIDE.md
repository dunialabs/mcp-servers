# MCP Server Template Usage Guide

## ğŸ“‹ Project Overview

This is a **complete, production-ready** TypeScript MCP Server template that combines:

1. **Modern McpServer API** (using official high-level API, clean and elegant)
2. **MCP Best Practices** (camelCase naming, XML description tags, detailed error handling)
3. **Complete Development Toolchain** (hot reload, linting, testing, formatting)

---

## âœ¨ Key Features

### Architecture Design
- âœ… **Clean Structure**: Uses McpServer high-level API with clear code organization (tools, types, utils)
- âœ… **Modern**: Direct tool registration in server.ts using `registerTool()`
- âœ… **Type Safe**: Zod schemas automatically convert to JSON Schema with complete type inference
- âœ… **Easy to Extend**: Adding new tools only requires calling registerTool() in server.ts

### MCP Best Practices
- âœ… **camelCase Tool Naming**: `echoMessage` instead of `echo_message`
- âœ… **Rich XML Descriptions**: Uses `<use_case>`, `<important_notes>`, `<examples>`, `<aliases>` tags
- âœ… **Server Instructions**: Detailed server-level instructions help LLM understand
- âœ… **Detailed Error Information**: Not just "not found", but specific context
- âœ… **stderr Logging**: All logs output to stderr, keeping stdout for MCP protocol
- âœ… **Modern API**: Uses McpServer instead of low-level Server API

### Development Experience
- âœ… **Hot Reload**: `npm run dev` automatically restarts on code changes
- âœ… **TypeScript Strict Mode**: Complete type safety
- âœ… **Zod Validation**: Runtime type validation + automatic schema conversion
- âœ… **ESLint + Prettier**: Code standards and formatting
- âœ… **Vitest Testing**: Unit testing framework
- âœ… **Environment Variables**: .env file for configuration management

---

## ğŸ“ Complete Project Structure

```
mcp-server-template/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ server.ts              # McpServer + tool/resource registration
â”‚   â”œâ”€â”€ tools/                 # Tool implementations (one file per tool)
â”‚   â”‚   â”œâ”€â”€ echo.ts            # Example: echo tool
â”‚   â”‚   â””â”€â”€ calculator.ts      # Example: calculator tool
â”‚   â”œâ”€â”€ types/                 # TypeScript type definitions
â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”œâ”€â”€ utils/                 # Utility functions
â”‚   â”‚   â””â”€â”€ logger.ts          # Logging system (stderr)
â”‚   â””â”€â”€ index.ts               # Entry point (signal handling, error catching)
â”œâ”€â”€ tests/                     # Test files
â”‚   â””â”€â”€ tools/
â”‚       â”œâ”€â”€ echo.test.ts
â”‚       â””â”€â”€ calculator.test.ts
â”œâ”€â”€ dist/                      # Build output (generated by npm run build)
â”œâ”€â”€ package.json               # Dependencies and scripts
â”œâ”€â”€ tsconfig.json              # TypeScript configuration
â”œâ”€â”€ .env.example               # Environment variable example
â”œâ”€â”€ .eslintrc.json             # ESLint configuration
â”œâ”€â”€ .prettierrc.json           # Prettier configuration
â”œâ”€â”€ .gitignore
â”œâ”€â”€ README.md                  # Complete usage documentation
â””â”€â”€ TEMPLATE_GUIDE.md          # This file
```

**Note**: No need for `handlers/` directory anymore, tools are directly registered in `server.ts` using `registerTool()`.

---

## ğŸš€ Quick Start

### 1. Initialize Project

```bash
cd /Users/tataufo/AboutMCP/mcp-server-template

# Install dependencies (already completed)
npm install

# Copy environment variables
cp .env.example .env

# Build project (already completed)
npm run build
```

### 2. Development Mode

```bash
# Start development server (with hot reload)
npm run dev
```

This runs TypeScript directly using `tsx`, automatically restarting when code changes.

### 3. Configure in Claude Desktop

**Configuration File Location**: `~/Library/Application Support/Claude/claude_desktop_config.json`

```json
{
  "mcpServers": {
    "template": {
      "command": "node",
      "args": [
        "/Users/tataufo/AboutMCP/mcp-server-template/dist/index.js"
      ]
    }
  }
}
```

Or use tsx in development mode:

```json
{
  "mcpServers": {
    "template-dev": {
      "command": "npx",
      "args": [
        "tsx",
        "/Users/tataufo/AboutMCP/mcp-server-template/src/index.ts"
      ],
      "env": {
        "NODE_ENV": "development"
      }
    }
  }
}
```

### 4. Test Server

```bash
# Run tests
npm test

# Watch mode
npm run test:watch
```

---

## ğŸ› ï¸ Available Tool Examples

### 1. echoMessage
- **Implementation**: `src/tools/echo.ts`
- **Registration**: `src/server.ts` (using `registerTool()`)
- **Functionality**: Echo messages with optional uppercase and repeat
- **Example**:
  ```json
  {
    "name": "echoMessage",
    "arguments": {
      "message": "Hello",
      "uppercase": true,
      "repeat": 2
    }
  }
  ```

### 2. performCalculation
- **Implementation**: `src/tools/calculator.ts`
- **Registration**: `src/server.ts` (using `registerTool()`)
- **Functionality**: Basic mathematical operations
- **Example**:
  ```json
  {
    "name": "performCalculation",
    "arguments": {
      "operation": "add",
      "a": 5,
      "b": 3
    }
  }
  ```

---

## ğŸ“š How to Extend

### Adding New Tools (Complete Flow)

#### Step 1: Create Tool Implementation

`src/tools/mytool.ts`:

```typescript
import { z } from 'zod';
import { logger } from '../utils/logger.js';

// Define input schema
const MyToolInput = z.object({
  param1: z.string().describe('Description of parameter 1'),
  param2: z.number().optional().describe('Description of parameter 2'),
});

export type MyToolInput = z.infer<typeof MyToolInput>;

export async function myTool(args: unknown): Promise<string> {
  // Validate input
  const input = MyToolInput.parse(args);

  logger.debug(`[myTool] Processing: ${input.param1}`);

  // Implementation logic
  const result = `Result: ${input.param1}`;

  return result;
}
```

#### Step 2: Register in server.ts

Add to the `setupTools()` method in `src/server.ts`:

```typescript
import { myTool } from './tools/mytool.js';

// Add to setupTools() method
this.server.registerTool(
  'myTool',  // camelCase naming
  {
    description: `<use_case>
Describe the purpose and use cases of this tool...
</use_case>

<important_notes>
- Important limitation 1
- Important limitation 2
</important_notes>

<examples>
Example 1: Simple usage
Input: { "param1": "test" }
Output: "Result: test"
</examples>

<aliases>
This tool can be used when users ask:
- "Perform some operation"
- "Help me do something"
</aliases>`,
    inputSchema: {
      param1: z.string().describe('Parameter 1'),
      param2: z.number().optional().describe('Parameter 2'),
    },
  },
  async ({ param1, param2 }) => {
    // Parameters are automatically validated and type-inferred
    logger.info(`[tools] Executing tool: myTool`);
    try {
      const result = await myTool({ param1, param2 });
      logger.debug(`[tools] Tool myTool executed successfully`);
      return {
        content: [{ type: 'text', text: result }],
      };
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      logger.error(`[tools] Error executing tool myTool:`, errorMessage);
      return {
        content: [{
          type: 'text',
          text: `Unable to execute tool "myTool".\n\nError: ${errorMessage}\n\nPlease check the tool description for correct usage and try again.`,
        }],
        isError: true,
      };
    }
  }
);
```

**Advantages**:
- âœ… Automatic parameter validation (Zod)
- âœ… Automatic type inference (TypeScript)
- âœ… Automatic schema conversion (Zod â†’ JSON Schema)
- âœ… Clean and concise code

#### Step 3: Testing

`tests/tools/mytool.test.ts`:

```typescript
import { describe, it, expect } from 'vitest';
import { myTool } from '../../src/tools/mytool.js';

describe('myTool', () => {
  it('should process input correctly', async () => {
    const result = await myTool({ param1: 'test' });
    expect(result).toBe('Result: test');
  });
});
```

---

### Adding New Resources

In the `setupResources()` method of `src/server.ts`:

**1. Add to resource list** (in ListResourcesRequestSchema handler):

```typescript
{
  uri: 'myapp://myresource',
  name: 'Resource Name',
  description: 'Resource description',
  mimeType: 'application/json',
}
```

**2. Implement read logic** (in ReadResourceRequestSchema handler's switch):

```typescript
case 'myapp://myresource':
  return {
    contents: [{
      uri: 'myapp://myresource',
      mimeType: 'application/json',
      text: JSON.stringify({
        data: 'your data here'
      }, null, 2),
    }],
  };
```

---

## ğŸ“ Development Script Explanations

| Command | Description | Use Case |
|---------|-------------|----------|
| `npm run dev` | Development mode (hot reload) | Use during development, auto-restarts on code changes |
| `npm run build` | Compile TypeScript | Build before production deployment |
| `npm start` | Run compiled code | Run production version |
| `npm test` | Run tests | Execute all unit tests |
| `npm run test:watch` | Watch mode testing | Continuous testing during development |
| `npm run lint` | Check code standards | CI/CD or pre-commit checks |
| `npm run lint:fix` | Auto-fix standards | Fix auto-fixable issues |
| `npm run format` | Format code | Unified code style |
| `npm run type-check` | TypeScript check | Type check only, no file generation |

---

## ğŸ¯ MCP Best Practices Checklist

When using this template, automatically follow these best practices:

- [x] **1.1 camelCase Tool Naming**: All tools use camelCase
- [x] **1.2 Tool Aliases**: Each tool description includes `<aliases>` section
- [x] **1.3 Rich Descriptions**: Use XML tags for structured descriptions
- [x] **1.4 Avoid Not Found**: Provide useful information instead of simple negation
- [x] **2.1 Server Instructions**: Detailed server-level instructions
- [x] **Logging Standards**: All logs output to stderr

---

## ğŸ”§ Common Tasks

### Modify Server Name and Version

In the `.env` file:

```bash
SERVER_NAME=my-awesome-server
SERVER_VERSION=2.0.0
```

### Add API Keys

In the `.env` file:

```bash
API_KEY=your_api_key_here
```

Use in code:

```typescript
const apiKey = process.env.API_KEY;
if (!apiKey) {
  throw new Error('API_KEY is required');
}
```

### Debug Logging

Log levels are automatically managed by the logger:

```typescript
import { logger } from '../utils/logger.js';

logger.debug('Detailed debug information');  // Only shown in development mode
logger.info('General information');
logger.warn('Warning information');
logger.error('Error information');
```

---

## ğŸ—ï¸ Architecture Evolution Guide

### Current Architecture: Single-File Centralized (Recommended for 2-10 tools)

This template uses direct tool registration in `src/server.ts`, which is the officially recommended approach suitable for small to medium projects.

**Advantages**:
- ğŸ“– **Easy to Understand**: All tool registration logic in one place
- ğŸ” **Simple Debugging**: No need to trace across files
- ğŸš€ **Fast Development**: Suitable for rapid prototyping and small projects
- âœ… **Follows Official Practices**: Official small servers (fetch, time) all use this approach

**Real-World Examples**:
- `@modelcontextprotocol/servers/fetch` - 1 tool
- `@modelcontextprotocol/servers/sequentialthinking` - 1 tool
- This template project - 2 example tools

---

### When to Consider Architecture Evolution?

#### ğŸš¦ Signal 1: Tool Count Growth (10-15+ tools)

**Symptoms**:
- `setupTools()` method exceeds 300 lines
- Scrolling to find tools becomes difficult
- Complex interdependencies between tools

**Solution**: Adopt **Modular + Manual Registration**

```typescript
// src/server.ts
import { weatherAlertsHandler } from './tools/weather-alerts.js';
import { forecastHandler } from './tools/forecast.js';

private setupTools() {
  this.server.registerTool('getWeatherAlerts', {...}, weatherAlertsHandler);
  this.server.registerTool('getForecast', {...}, forecastHandler);
}

// src/tools/weather-alerts.ts
export async function weatherAlertsHandler(args: WeatherAlertsInput) {
  const input = WeatherAlertsInput.parse(args);
  // Implementation logic
  return result;
}
```

**Advantages**:
- ğŸ—‚ï¸ Separation of concerns: tool implementation and registration separated
- ğŸ§ª Easy to test: can test each tool independently
- ğŸ‘¥ Team collaboration: different people develop different tool files

**Reference Projects**:
- `@modelcontextprotocol/servers/git` - 12+ Git tools, uses modular approach
- `@modelcontextprotocol/servers/filesystem` - 13 file tools

---

#### ğŸš¦ Signal 2: Frequent Team Collaboration Conflicts

**Symptoms**:
- Multiple people modifying `server.ts` simultaneously causes Git merge conflicts
- PR changes are too large during code review
- Tool development blocks each other

**Solution**: Each tool in separate file + directory organization

```
src/
â”œâ”€â”€ server.ts              # Only responsible for registration
â”œâ”€â”€ tools/
â”‚   â”œâ”€â”€ weather/           # Group by functionality
â”‚   â”‚   â”œâ”€â”€ alerts.ts
â”‚   â”‚   â””â”€â”€ forecast.ts
â”‚   â”œâ”€â”€ location/
â”‚   â”‚   â””â”€â”€ geocode.ts
â”‚   â””â”€â”€ index.ts           # Unified exports
```

---

#### ğŸš¦ Signal 3: Cross-Project Tool Reuse (Advanced Scenario)

**Symptoms**:
- Need to share tools across multiple MCP servers
- Tools have independent versions and configurations
- Need to dynamically load/unload tools

**Solution**: Adopt **Auto-Discovery Pattern** (plugin-based)

```typescript
// tools/weatherAlerts.ts - Each tool is an independent module
export default {
  type: 'tool' as const,
  name: 'getWeatherAlerts',
  description: 'Weather alerts tool',
  register: (server: McpServer) => {
    server.registerTool('getWeatherAlerts', {
      description: '...',
      inputSchema: {...},
    }, async (args) => {...});
  }
};

// server.ts - Auto-discovery and loading
import { glob } from 'glob';

async function autoLoadTools(server: McpServer) {
  const toolFiles = await glob('tools/**/*.ts');
  for (const file of toolFiles) {
    const module = await import(file);
    if (module.default?.register) {
      module.default.register(server);
    }
  }
}
```

**Community Frameworks**:
- [fastmcp](https://github.com/punkpeye/fastmcp) - Provides plugin architecture
- [mcp-server-starter-ts](https://github.com/alexanderop/mcp-server-starter-ts) - Auto-loading template

---

### ğŸ“Š Architecture Comparison Summary

| Architecture Pattern | Suitable Scale | Complexity | Team Collaboration | Example Projects |
|---------------------|----------------|------------|-------------------|------------------|
| **Single-File Centralized** | 2-10 tools | â­ Low | â­â­ Medium | This template |
| **Modular Manual Registration** | 10-30 tools | â­â­ Medium | â­â­â­ Good | git, filesystem |
| **Auto-Discovery Plugin** | 30+ tools | â­â­â­ High | â­â­â­ Good | fastmcp |

---

### ğŸ’¡ Best Practice Recommendations

1. **Start Simple** ğŸ¯
   - New projects use current single-file architecture
   - Wait until tool count grows before refactoring

2. **Progressive Evolution** ğŸ“ˆ
   - Don't over-optimize prematurely
   - Let code pain points tell you when to refactor

3. **Reference Official Practices** âœ…
   - Small servers (â‰¤5 tools): Single-file centralized
   - Medium servers (6-15 tools): Modular approach
   - Large servers (15+ tools): Consider frameworks

4. **Maintain Testing** ğŸ§ª
   - Regardless of architecture, tool logic should be independently testable
   - Reference test examples in `tests/tools/` directory

---

## ğŸ› Troubleshooting

### Issue 1: Build Failure

```bash
# Clean and rebuild
npm run clean
npm run build
```

### Issue 2: Module Not Found at Runtime

Ensure:
1. `npm install` completed
2. `npm run build` executed successfully
3. `dist/` directory exists and contains .js files

### Issue 3: Claude Desktop Cannot Connect

Check:
1. Configuration file path is correct (use absolute path)
2. Server built successfully
3. Claude Desktop restarted

View server logs (stderr) to diagnose issues.

---

## ğŸ“¦ Deployment Suggestions

### Publish to npm

1. Update `package.json`:
   ```json
   {
     "name": "@yourname/your-mcp-server",
     "private": false,
     "author": "Your Name <your@email.com>",
     "repository": "https://github.com/yourname/your-mcp-server"
   }
   ```

2. Publish:
   ```bash
   npm login
   npm publish --access public
   ```

3. Users can use via npx:
   ```bash
   npx @yourname/your-mcp-server
   ```

### Docker Deployment

Create `Dockerfile`:

```dockerfile
FROM node:18-alpine
WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production
COPY dist ./dist
CMD ["node", "dist/index.js"]
```

Build and run:

```bash
docker build -t my-mcp-server .
docker run --rm -i my-mcp-server
```

---

## ğŸ“ Learning Resources

- **README.md**: Complete usage documentation
- **src/server.ts**: McpServer API and tool registration examples
- **src/tools/**: Tool implementation examples
- **tests/**: Testing examples

---

## âœ… Verification Checklist

After building, verify the following:

- [ ] `npm run build` executes successfully
- [ ] `dist/` directory contains compiled JavaScript files
- [ ] `npm test` all tests pass
- [ ] `npm run lint` no errors
- [ ] Successfully connects in Claude Desktop
- [ ] Tool calls work correctly
- [ ] Resource reads work correctly

---

**This template is ready to use directly and can serve as the foundation for your future development!** ğŸš€
